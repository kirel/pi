---
- name: Create folder config folders
  ansible.builtin.file:
    path: "{{ item }}"
    state: directory
    owner: "{{ username }}"
    group: "{{ username }}"
    mode: "0755"
  with_items:
    - "{{ caddy_folder }}"
    - "{{ caddy_data_folder }}"
    - "{{ caddy_config_folder }}"

- name: Reposess config folders
  ansible.builtin.file:
    path: "{{ item }}"
    owner: "{{ username }}"
    group: users
    mode: u=rwx,g=rwxs
    recurse: true
  with_items:
    - "{{ caddy_folder }}"
    - "{{ caddy_data_folder }}"
    - "{{ caddy_config_folder }}"

- name: Copy Caddyfile
  ansible.builtin.template:
    src: Caddyfile.j2
    dest: "{{ caddy_folder }}/Caddyfile"
    owner: "{{ username }}"
    mode: "0644"
  register: caddyfile
  notify: Reload Caddy

- name: Copy Dockerfile
  ansible.builtin.template:
    src: Dockerfile
    dest: "{{ caddy_folder }}/Dockerfile"
    owner: "{{ username }}"
    mode: "0644"
  register: dockerfile

- name: Start caddy
  community.docker.docker_compose_v2:
    project_name: caddy
    pull: always # or "missing", "never", "policy" based on your needs
    build: always # or "always", "never"
    state: present # Ensure the services are started
    definition:
      # Networks are not used in host network mode for this service
      services:
        caddy:
          network_mode: host
          container_name: caddy
          build:
            context: "{{ caddy_folder }}"
            dockerfile: "{{ caddy_folder }}/Dockerfile"
          restart: unless-stopped
          user: "{{ uid }}:{{ uid }}"
          volumes:
            - "{{ caddy_folder }}/Caddyfile:/etc/caddy/Caddyfile"
            - "{{ caddy_data_folder }}:/data"
            - "{{ caddy_config_folder }}:/config"
          environment:
            CADDY_ADMIN: "0.0.0.0:2019"
          dns:
            - "{{ nameserver_pi_ip }}"
            - "{{ homelab_nuc_ip }}"
          cap_add:
            - NET_ADMIN
          labels:
            - wud.tag.include=latest
            - wud.watch.digest=true
            - homepage.group=Network
            - homepage.name=Caddy
            - homepage.icon=mdi-server
            - homepage.server={{ inventory_hostname }}
            - homepage.container=caddy
            - homepage.widget.type=caddy
            - homepage.widget.url=http://homelab-nuc.lan:2019 # Use host-resolvable name as Caddy is in host network mode

  register: output

- name: Debug docker compose output
  ansible.builtin.debug:
    var: output

- name: Assert caddy container is running
  ansible.builtin.assert:
    that:
      - output.containers | selectattr('Name', 'equalto', 'caddy') | list | length > 0
      - output.containers | selectattr('Name', 'equalto', 'caddy') | map(attribute='State') | list | first == 'running'

- name: Create symlink to root certificate from mounted data volume
  ansible.builtin.file:
    src: "{{ caddy_data_folder }}/caddy/pki/authorities/local/root.crt"
    dest: "{{ caddy_folder }}/root.crt"
    state: link
    owner: "{{ username }}"
    group: users

- name: Ensure Caddy PKI directories are world-executable for service mounts
  ansible.builtin.file:
    path: "{{ item }}"
    state: directory
    mode: "0755"
    owner: "{{ username }}"
    group: users
  loop:
    - "{{ caddy_data_folder }}/caddy/pki"
    - "{{ caddy_data_folder }}/caddy/pki/authorities"
    - "{{ caddy_data_folder }}/caddy/pki/authorities/local"

- name: Ensure Caddy root certificate is world-readable for service mounts
  ansible.builtin.file:
    path: "{{ caddy_data_folder }}/caddy/pki/authorities/local/root.crt"
    mode: "0644"
    owner: "{{ username }}"
    group: users

- name: Fetch root certificate to controller for distribution
  ansible.builtin.fetch:
    src: "{{ caddy_folder }}/root.crt"
    dest: tmp/
    flat: true


# Note: The certificate is accessible via the mounted data volume at:
# {{ caddy_data_folder }}/caddy/pki/authorities/local/root.crt
# The symlink provides a convenient stable path at {{ caddy_folder }}/root.crt

# Note: Installing the cert into the host's trust store is now handled by the 'trust-internal-ca' role.
# The fetch task above provides the cert to the controller so it can be distributed to all hosts.
